//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticationLogin(body: LoginDto | undefined): Promise<TokenDto> {
        let url_ = this.baseUrl + "/api/Authentication/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuthenticationLogin(_response);
        });
    }

    protected processAuthenticationLogin(response: Response): Promise<TokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticationCreateUser(body: UserDto | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/Authentication/CreateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuthenticationCreateUser(_response);
        });
    }

    protected processAuthenticationCreateUser(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @return Success
     */
    authenticationGetUserSession(): Promise<SessionDto> {
        let url_ = this.baseUrl + "/api/Authentication/GetUserSession";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuthenticationGetUserSession(_response);
        });
    }

    protected processAuthenticationGetUserSession(response: Response): Promise<SessionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SessionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SessionDto>(null as any);
    }

    /**
     * @return Success
     */
    authenticationGetUsers(): Promise<UserDtoPagingResultDto> {
        let url_ = this.baseUrl + "/api/Authentication/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuthenticationGetUsers(_response);
        });
    }

    protected processAuthenticationGetUsers(response: Response): Promise<UserDtoPagingResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagingResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDtoPagingResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticationUpdateUser(body: UserDto | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/Authentication/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuthenticationUpdateUser(_response);
        });
    }

    protected processAuthenticationUpdateUser(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    authenticationUpdateDelete(id: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Authentication/UpdateDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuthenticationUpdateDelete(_response);
        });
    }

    protected processAuthenticationUpdateDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderByField (optional) 
     * @param orderType (optional) 
     * @param filter (optional) 
     * @param hiddenFilter (optional) 
     * @return Success
     */
    banksGetAll(pageNumber: number | undefined, pageSize: number | undefined, orderByField: string | undefined, orderType: string | undefined, filter: string | undefined, hiddenFilter: string | undefined): Promise<BanksDtoPagingResultDto> {
        let url_ = this.baseUrl + "/api/Banks/GetAll?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderByField === null)
            throw new Error("The parameter 'orderByField' cannot be null.");
        else if (orderByField !== undefined)
            url_ += "OrderByField=" + encodeURIComponent("" + orderByField) + "&";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (hiddenFilter === null)
            throw new Error("The parameter 'hiddenFilter' cannot be null.");
        else if (hiddenFilter !== undefined)
            url_ += "HiddenFilter=" + encodeURIComponent("" + hiddenFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBanksGetAll(_response);
        });
    }

    protected processBanksGetAll(response: Response): Promise<BanksDtoPagingResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BanksDtoPagingResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BanksDtoPagingResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    banksGet(id: number | undefined): Promise<BanksDto> {
        let url_ = this.baseUrl + "/api/Banks/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBanksGet(_response);
        });
    }

    protected processBanksGet(response: Response): Promise<BanksDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BanksDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BanksDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    banksCreate(body: BanksDto | undefined): Promise<BanksDto> {
        let url_ = this.baseUrl + "/api/Banks/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBanksCreate(_response);
        });
    }

    protected processBanksCreate(response: Response): Promise<BanksDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BanksDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BanksDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    banksUpdate(body: BanksDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Banks/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBanksUpdate(_response);
        });
    }

    protected processBanksUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    banksDelete(id: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Banks/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBanksDelete(_response);
        });
    }

    protected processBanksDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderByField (optional) 
     * @param orderType (optional) 
     * @param filter (optional) 
     * @param hiddenFilter (optional) 
     * @return Success
     */
    countriesGetAll(pageNumber: number | undefined, pageSize: number | undefined, orderByField: string | undefined, orderType: string | undefined, filter: string | undefined, hiddenFilter: string | undefined): Promise<CountriesDtoPagingResultDto> {
        let url_ = this.baseUrl + "/api/Countries/GetAll?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderByField === null)
            throw new Error("The parameter 'orderByField' cannot be null.");
        else if (orderByField !== undefined)
            url_ += "OrderByField=" + encodeURIComponent("" + orderByField) + "&";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (hiddenFilter === null)
            throw new Error("The parameter 'hiddenFilter' cannot be null.");
        else if (hiddenFilter !== undefined)
            url_ += "HiddenFilter=" + encodeURIComponent("" + hiddenFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountriesGetAll(_response);
        });
    }

    protected processCountriesGetAll(response: Response): Promise<CountriesDtoPagingResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountriesDtoPagingResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountriesDtoPagingResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    countriesGet(id: number | undefined): Promise<CountriesDto> {
        let url_ = this.baseUrl + "/api/Countries/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountriesGet(_response);
        });
    }

    protected processCountriesGet(response: Response): Promise<CountriesDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountriesDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountriesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    countriesCreate(body: CountriesDto | undefined): Promise<CountriesDto> {
        let url_ = this.baseUrl + "/api/Countries/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountriesCreate(_response);
        });
    }

    protected processCountriesCreate(response: Response): Promise<CountriesDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountriesDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountriesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    countriesUpdate(body: CountriesDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Countries/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountriesUpdate(_response);
        });
    }

    protected processCountriesUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    countriesDelete(id: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Countries/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountriesDelete(_response);
        });
    }

    protected processCountriesDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderByField (optional) 
     * @param orderType (optional) 
     * @param filter (optional) 
     * @param hiddenFilter (optional) 
     * @return Success
     */
    currenciesGetAll(pageNumber: number | undefined, pageSize: number | undefined, orderByField: string | undefined, orderType: string | undefined, filter: string | undefined, hiddenFilter: string | undefined): Promise<CurrenciesDtoPagingResultDto> {
        let url_ = this.baseUrl + "/api/Currencies/GetAll?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderByField === null)
            throw new Error("The parameter 'orderByField' cannot be null.");
        else if (orderByField !== undefined)
            url_ += "OrderByField=" + encodeURIComponent("" + orderByField) + "&";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (hiddenFilter === null)
            throw new Error("The parameter 'hiddenFilter' cannot be null.");
        else if (hiddenFilter !== undefined)
            url_ += "HiddenFilter=" + encodeURIComponent("" + hiddenFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrenciesGetAll(_response);
        });
    }

    protected processCurrenciesGetAll(response: Response): Promise<CurrenciesDtoPagingResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrenciesDtoPagingResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CurrenciesDtoPagingResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    currenciesGet(id: number | undefined): Promise<CurrenciesDto> {
        let url_ = this.baseUrl + "/api/Currencies/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrenciesGet(_response);
        });
    }

    protected processCurrenciesGet(response: Response): Promise<CurrenciesDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrenciesDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CurrenciesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    currenciesCreate(body: CurrenciesDto | undefined): Promise<CurrenciesDto> {
        let url_ = this.baseUrl + "/api/Currencies/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrenciesCreate(_response);
        });
    }

    protected processCurrenciesCreate(response: Response): Promise<CurrenciesDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrenciesDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CurrenciesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    currenciesUpdate(body: CurrenciesDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Currencies/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrenciesUpdate(_response);
        });
    }

    protected processCurrenciesUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    currenciesDelete(id: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Currencies/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrenciesDelete(_response);
        });
    }

    protected processCurrenciesDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    currenciesSetDefaultCurrency(id: number | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Currencies/SetDefaultCurrency?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrenciesSetDefaultCurrency(_response);
        });
    }

    protected processCurrenciesSetDefaultCurrency(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    currenciesGetDefaultCurrency(): Promise<CurrenciesDto> {
        let url_ = this.baseUrl + "/api/Currencies/GetDefaultCurrency";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrenciesGetDefaultCurrency(_response);
        });
    }

    protected processCurrenciesGetDefaultCurrency(response: Response): Promise<CurrenciesDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrenciesDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CurrenciesDto>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderByField (optional) 
     * @param orderType (optional) 
     * @param filter (optional) 
     * @param hiddenFilter (optional) 
     * @return Success
     */
    identitySourcesGetAll(pageNumber: number | undefined, pageSize: number | undefined, orderByField: string | undefined, orderType: string | undefined, filter: string | undefined, hiddenFilter: string | undefined): Promise<IdentitySourcesDtoPagingResultDto> {
        let url_ = this.baseUrl + "/api/IdentitySources/GetAll?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderByField === null)
            throw new Error("The parameter 'orderByField' cannot be null.");
        else if (orderByField !== undefined)
            url_ += "OrderByField=" + encodeURIComponent("" + orderByField) + "&";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (hiddenFilter === null)
            throw new Error("The parameter 'hiddenFilter' cannot be null.");
        else if (hiddenFilter !== undefined)
            url_ += "HiddenFilter=" + encodeURIComponent("" + hiddenFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIdentitySourcesGetAll(_response);
        });
    }

    protected processIdentitySourcesGetAll(response: Response): Promise<IdentitySourcesDtoPagingResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentitySourcesDtoPagingResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentitySourcesDtoPagingResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    identitySourcesGet(id: number | undefined): Promise<IdentitySourcesDto> {
        let url_ = this.baseUrl + "/api/IdentitySources/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIdentitySourcesGet(_response);
        });
    }

    protected processIdentitySourcesGet(response: Response): Promise<IdentitySourcesDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentitySourcesDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentitySourcesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    identitySourcesCreate(body: IdentitySourcesDto | undefined): Promise<IdentitySourcesDto> {
        let url_ = this.baseUrl + "/api/IdentitySources/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIdentitySourcesCreate(_response);
        });
    }

    protected processIdentitySourcesCreate(response: Response): Promise<IdentitySourcesDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentitySourcesDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentitySourcesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    identitySourcesUpdate(body: IdentitySourcesDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/IdentitySources/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIdentitySourcesUpdate(_response);
        });
    }

    protected processIdentitySourcesUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    identitySourcesDelete(id: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/IdentitySources/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIdentitySourcesDelete(_response);
        });
    }

    protected processIdentitySourcesDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderByField (optional) 
     * @param orderType (optional) 
     * @param filter (optional) 
     * @param hiddenFilter (optional) 
     * @return Success
     */
    jobsGetAll(pageNumber: number | undefined, pageSize: number | undefined, orderByField: string | undefined, orderType: string | undefined, filter: string | undefined, hiddenFilter: string | undefined): Promise<JobsDtoPagingResultDto> {
        let url_ = this.baseUrl + "/api/Jobs/GetAll?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderByField === null)
            throw new Error("The parameter 'orderByField' cannot be null.");
        else if (orderByField !== undefined)
            url_ += "OrderByField=" + encodeURIComponent("" + orderByField) + "&";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (hiddenFilter === null)
            throw new Error("The parameter 'hiddenFilter' cannot be null.");
        else if (hiddenFilter !== undefined)
            url_ += "HiddenFilter=" + encodeURIComponent("" + hiddenFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJobsGetAll(_response);
        });
    }

    protected processJobsGetAll(response: Response): Promise<JobsDtoPagingResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobsDtoPagingResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobsDtoPagingResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    jobsGet(id: number | undefined): Promise<JobsDto> {
        let url_ = this.baseUrl + "/api/Jobs/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJobsGet(_response);
        });
    }

    protected processJobsGet(response: Response): Promise<JobsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    jobsCreate(body: JobsDto | undefined): Promise<JobsDto> {
        let url_ = this.baseUrl + "/api/Jobs/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJobsCreate(_response);
        });
    }

    protected processJobsCreate(response: Response): Promise<JobsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    jobsUpdate(body: JobsDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Jobs/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJobsUpdate(_response);
        });
    }

    protected processJobsUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    jobsDelete(id: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Jobs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJobsDelete(_response);
        });
    }

    protected processJobsDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param screensId (optional) 
     * @return Success
     */
    privilageGetPrivilageTypes(screensId: number | undefined): Promise<PrivilageTypeDtoPagingResultDto> {
        let url_ = this.baseUrl + "/api/Privilage/GetPrivilageTypes?";
        if (screensId === null)
            throw new Error("The parameter 'screensId' cannot be null.");
        else if (screensId !== undefined)
            url_ += "screensId=" + encodeURIComponent("" + screensId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrivilageGetPrivilageTypes(_response);
        });
    }

    protected processPrivilageGetPrivilageTypes(response: Response): Promise<PrivilageTypeDtoPagingResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrivilageTypeDtoPagingResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PrivilageTypeDtoPagingResultDto>(null as any);
    }

    /**
     * @return Success
     */
    privilageGetAllPrivilageTypes(): Promise<PrivilageTypeDtoPagingResultDto> {
        let url_ = this.baseUrl + "/api/Privilage/GetAllPrivilageTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrivilageGetAllPrivilageTypes(_response);
        });
    }

    protected processPrivilageGetAllPrivilageTypes(response: Response): Promise<PrivilageTypeDtoPagingResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrivilageTypeDtoPagingResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PrivilageTypeDtoPagingResultDto>(null as any);
    }

    /**
     * @return Success
     */
    privilageGetScreens(): Promise<ScreensDtoPagingResultDto> {
        let url_ = this.baseUrl + "/api/Privilage/GetScreens";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrivilageGetScreens(_response);
        });
    }

    protected processPrivilageGetScreens(response: Response): Promise<ScreensDtoPagingResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScreensDtoPagingResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScreensDtoPagingResultDto>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderByField (optional) 
     * @param orderType (optional) 
     * @param filter (optional) 
     * @param hiddenFilter (optional) 
     * @return Success
     */
    privilageGetAll(pageNumber: number | undefined, pageSize: number | undefined, orderByField: string | undefined, orderType: string | undefined, filter: string | undefined, hiddenFilter: string | undefined): Promise<PrivilageDtoPagingResultDto> {
        let url_ = this.baseUrl + "/api/Privilage/GetAll?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderByField === null)
            throw new Error("The parameter 'orderByField' cannot be null.");
        else if (orderByField !== undefined)
            url_ += "OrderByField=" + encodeURIComponent("" + orderByField) + "&";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (hiddenFilter === null)
            throw new Error("The parameter 'hiddenFilter' cannot be null.");
        else if (hiddenFilter !== undefined)
            url_ += "HiddenFilter=" + encodeURIComponent("" + hiddenFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrivilageGetAll(_response);
        });
    }

    protected processPrivilageGetAll(response: Response): Promise<PrivilageDtoPagingResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrivilageDtoPagingResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PrivilageDtoPagingResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    privilageGet(id: number | undefined): Promise<PrivilageDto> {
        let url_ = this.baseUrl + "/api/Privilage/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrivilageGet(_response);
        });
    }

    protected processPrivilageGet(response: Response): Promise<PrivilageDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrivilageDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PrivilageDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    privilageCreate(body: PrivilageDto | undefined): Promise<PrivilageDto> {
        let url_ = this.baseUrl + "/api/Privilage/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrivilageCreate(_response);
        });
    }

    protected processPrivilageCreate(response: Response): Promise<PrivilageDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrivilageDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PrivilageDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    privilageUpdate(body: PrivilageDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Privilage/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrivilageUpdate(_response);
        });
    }

    protected processPrivilageUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param privilageTypeId (optional) 
     * @param userid (optional) 
     * @param screenid (optional) 
     * @return Success
     */
    privilageCheckAuth(privilageTypeId: number | undefined, userid: string | undefined, screenid: number | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Privilage/CheckAuth?";
        if (privilageTypeId === null)
            throw new Error("The parameter 'privilageTypeId' cannot be null.");
        else if (privilageTypeId !== undefined)
            url_ += "PrivilageTypeId=" + encodeURIComponent("" + privilageTypeId) + "&";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        if (screenid === null)
            throw new Error("The parameter 'screenid' cannot be null.");
        else if (screenid !== undefined)
            url_ += "screenid=" + encodeURIComponent("" + screenid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrivilageCheckAuth(_response);
        });
    }

    protected processPrivilageCheckAuth(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param screenName (optional) 
     * @param privilageTypeName (optional) 
     * @return Success
     */
    privilageCheckAuthByName(userId: string | undefined, screenName: string | undefined, privilageTypeName: string | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Privilage/CheckAuthByName?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (screenName === null)
            throw new Error("The parameter 'screenName' cannot be null.");
        else if (screenName !== undefined)
            url_ += "screenName=" + encodeURIComponent("" + screenName) + "&";
        if (privilageTypeName === null)
            throw new Error("The parameter 'privilageTypeName' cannot be null.");
        else if (privilageTypeName !== undefined)
            url_ += "PrivilageTypeName=" + encodeURIComponent("" + privilageTypeName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrivilageCheckAuthByName(_response);
        });
    }

    protected processPrivilageCheckAuthByName(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    privilageDelete(id: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Privilage/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrivilageDelete(_response);
        });
    }

    protected processPrivilageDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    privilageAutoFill(): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Privilage/AutoFill";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrivilageAutoFill(_response);
        });
    }

    protected processPrivilageAutoFill(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderByField (optional) 
     * @param orderType (optional) 
     * @param filter (optional) 
     * @param hiddenFilter (optional) 
     * @return Success
     */
    transferPurposesGetAll(pageNumber: number | undefined, pageSize: number | undefined, orderByField: string | undefined, orderType: string | undefined, filter: string | undefined, hiddenFilter: string | undefined): Promise<TransferPurposesDtoPagingResultDto> {
        let url_ = this.baseUrl + "/api/TransferPurposes/GetAll?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderByField === null)
            throw new Error("The parameter 'orderByField' cannot be null.");
        else if (orderByField !== undefined)
            url_ += "OrderByField=" + encodeURIComponent("" + orderByField) + "&";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (hiddenFilter === null)
            throw new Error("The parameter 'hiddenFilter' cannot be null.");
        else if (hiddenFilter !== undefined)
            url_ += "HiddenFilter=" + encodeURIComponent("" + hiddenFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTransferPurposesGetAll(_response);
        });
    }

    protected processTransferPurposesGetAll(response: Response): Promise<TransferPurposesDtoPagingResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransferPurposesDtoPagingResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransferPurposesDtoPagingResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    transferPurposesGet(id: number | undefined): Promise<TransferPurposesDto> {
        let url_ = this.baseUrl + "/api/TransferPurposes/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTransferPurposesGet(_response);
        });
    }

    protected processTransferPurposesGet(response: Response): Promise<TransferPurposesDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransferPurposesDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransferPurposesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    transferPurposesCreate(body: TransferPurposesDto | undefined): Promise<TransferPurposesDto> {
        let url_ = this.baseUrl + "/api/TransferPurposes/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTransferPurposesCreate(_response);
        });
    }

    protected processTransferPurposesCreate(response: Response): Promise<TransferPurposesDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransferPurposesDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransferPurposesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    transferPurposesUpdate(body: TransferPurposesDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/TransferPurposes/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTransferPurposesUpdate(_response);
        });
    }

    protected processTransferPurposesUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    transferPurposesDelete(id: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/TransferPurposes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTransferPurposesDelete(_response);
        });
    }

    protected processTransferPurposesDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    weatherForecastGet(): Promise<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWeatherForecastGet(_response);
        });
    }

    protected processWeatherForecastGet(response: Response): Promise<WeatherForecast[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WeatherForecast[]>(null as any);
    }
}

export class BanksDto implements IBanksDto {
    id?: number;
    readOnly?: boolean;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    riskRate?: number;
    isActve?: number;

    constructor(data?: IBanksDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.readOnly = _data["readOnly"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.riskRate = _data["riskRate"];
            this.isActve = _data["isActve"];
        }
    }

    static fromJS(data: any): BanksDto {
        data = typeof data === 'object' ? data : {};
        let result = new BanksDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["readOnly"] = this.readOnly;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["riskRate"] = this.riskRate;
        data["isActve"] = this.isActve;
        return data;
    }
}

export interface IBanksDto {
    id?: number;
    readOnly?: boolean;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    riskRate?: number;
    isActve?: number;
}

export class BanksDtoPagingResultDto implements IBanksDtoPagingResultDto {
    total?: number;
    result?: BanksDto[] | undefined;

    constructor(data?: IBanksDtoPagingResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(BanksDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BanksDtoPagingResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BanksDtoPagingResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBanksDtoPagingResultDto {
    total?: number;
    result?: BanksDto[] | undefined;
}

export class CountriesDto implements ICountriesDto {
    id?: number;
    readOnly?: boolean;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    riskRate?: number;
    isActve?: number;

    constructor(data?: ICountriesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.readOnly = _data["readOnly"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.riskRate = _data["riskRate"];
            this.isActve = _data["isActve"];
        }
    }

    static fromJS(data: any): CountriesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountriesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["readOnly"] = this.readOnly;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["riskRate"] = this.riskRate;
        data["isActve"] = this.isActve;
        return data;
    }
}

export interface ICountriesDto {
    id?: number;
    readOnly?: boolean;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    riskRate?: number;
    isActve?: number;
}

export class CountriesDtoPagingResultDto implements ICountriesDtoPagingResultDto {
    total?: number;
    result?: CountriesDto[] | undefined;

    constructor(data?: ICountriesDtoPagingResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CountriesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CountriesDtoPagingResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountriesDtoPagingResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICountriesDtoPagingResultDto {
    total?: number;
    result?: CountriesDto[] | undefined;
}

export class CurrenciesDto implements ICurrenciesDto {
    id?: number;
    readOnly?: boolean;
    countryId?: number;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    currCode?: string | undefined;
    isDefault?: boolean | undefined;
    riskRate?: number;
    isActve?: number;

    constructor(data?: ICurrenciesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.readOnly = _data["readOnly"];
            this.countryId = _data["countryId"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.currCode = _data["currCode"];
            this.isDefault = _data["isDefault"];
            this.riskRate = _data["riskRate"];
            this.isActve = _data["isActve"];
        }
    }

    static fromJS(data: any): CurrenciesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrenciesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["readOnly"] = this.readOnly;
        data["countryId"] = this.countryId;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["currCode"] = this.currCode;
        data["isDefault"] = this.isDefault;
        data["riskRate"] = this.riskRate;
        data["isActve"] = this.isActve;
        return data;
    }
}

export interface ICurrenciesDto {
    id?: number;
    readOnly?: boolean;
    countryId?: number;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    currCode?: string | undefined;
    isDefault?: boolean | undefined;
    riskRate?: number;
    isActve?: number;
}

export class CurrenciesDtoPagingResultDto implements ICurrenciesDtoPagingResultDto {
    total?: number;
    result?: CurrenciesDto[] | undefined;

    constructor(data?: ICurrenciesDtoPagingResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CurrenciesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CurrenciesDtoPagingResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrenciesDtoPagingResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICurrenciesDtoPagingResultDto {
    total?: number;
    result?: CurrenciesDto[] | undefined;
}

export class IdentitySourcesDto implements IIdentitySourcesDto {
    id?: number;
    readOnly?: boolean;
    countryId?: number;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    riskRate?: number;
    isActve?: number;

    constructor(data?: IIdentitySourcesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.readOnly = _data["readOnly"];
            this.countryId = _data["countryId"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.riskRate = _data["riskRate"];
            this.isActve = _data["isActve"];
        }
    }

    static fromJS(data: any): IdentitySourcesDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentitySourcesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["readOnly"] = this.readOnly;
        data["countryId"] = this.countryId;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["riskRate"] = this.riskRate;
        data["isActve"] = this.isActve;
        return data;
    }
}

export interface IIdentitySourcesDto {
    id?: number;
    readOnly?: boolean;
    countryId?: number;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    riskRate?: number;
    isActve?: number;
}

export class IdentitySourcesDtoPagingResultDto implements IIdentitySourcesDtoPagingResultDto {
    total?: number;
    result?: IdentitySourcesDto[] | undefined;

    constructor(data?: IIdentitySourcesDtoPagingResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(IdentitySourcesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentitySourcesDtoPagingResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentitySourcesDtoPagingResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIdentitySourcesDtoPagingResultDto {
    total?: number;
    result?: IdentitySourcesDto[] | undefined;
}

export class JobsDto implements IJobsDto {
    id?: number;
    readOnly?: boolean;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    riskRate?: number;
    isActve?: number;

    constructor(data?: IJobsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.readOnly = _data["readOnly"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.riskRate = _data["riskRate"];
            this.isActve = _data["isActve"];
        }
    }

    static fromJS(data: any): JobsDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["readOnly"] = this.readOnly;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["riskRate"] = this.riskRate;
        data["isActve"] = this.isActve;
        return data;
    }
}

export interface IJobsDto {
    id?: number;
    readOnly?: boolean;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    riskRate?: number;
    isActve?: number;
}

export class JobsDtoPagingResultDto implements IJobsDtoPagingResultDto {
    total?: number;
    result?: JobsDto[] | undefined;

    constructor(data?: IJobsDtoPagingResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(JobsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JobsDtoPagingResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobsDtoPagingResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface IJobsDtoPagingResultDto {
    total?: number;
    result?: JobsDto[] | undefined;
}

export class LoginDto implements ILoginDto {
    userName!: string;
    password!: string;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginDto {
    userName: string;
    password: string;
}

export class PrivilageDto implements IPrivilageDto {
    id?: number;
    readOnly?: boolean;
    screensId?: number;
    privilageTypeId?: number;
    jobId?: number;
    state?: number;

    constructor(data?: IPrivilageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.readOnly = _data["readOnly"];
            this.screensId = _data["screensId"];
            this.privilageTypeId = _data["privilageTypeId"];
            this.jobId = _data["jobId"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): PrivilageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrivilageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["readOnly"] = this.readOnly;
        data["screensId"] = this.screensId;
        data["privilageTypeId"] = this.privilageTypeId;
        data["jobId"] = this.jobId;
        data["state"] = this.state;
        return data;
    }
}

export interface IPrivilageDto {
    id?: number;
    readOnly?: boolean;
    screensId?: number;
    privilageTypeId?: number;
    jobId?: number;
    state?: number;
}

export class PrivilageDtoPagingResultDto implements IPrivilageDtoPagingResultDto {
    total?: number;
    result?: PrivilageDto[] | undefined;

    constructor(data?: IPrivilageDtoPagingResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PrivilageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrivilageDtoPagingResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrivilageDtoPagingResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPrivilageDtoPagingResultDto {
    total?: number;
    result?: PrivilageDto[] | undefined;
}

export class PrivilageTypeDto implements IPrivilageTypeDto {
    privilageTypeId?: number;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    screensId?: number;

    constructor(data?: IPrivilageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.privilageTypeId = _data["privilageTypeId"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.screensId = _data["screensId"];
        }
    }

    static fromJS(data: any): PrivilageTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrivilageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["privilageTypeId"] = this.privilageTypeId;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["screensId"] = this.screensId;
        return data;
    }
}

export interface IPrivilageTypeDto {
    privilageTypeId?: number;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    screensId?: number;
}

export class PrivilageTypeDtoPagingResultDto implements IPrivilageTypeDtoPagingResultDto {
    total?: number;
    result?: PrivilageTypeDto[] | undefined;

    constructor(data?: IPrivilageTypeDtoPagingResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PrivilageTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrivilageTypeDtoPagingResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrivilageTypeDtoPagingResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPrivilageTypeDtoPagingResultDto {
    total?: number;
    result?: PrivilageTypeDto[] | undefined;
}

export class ScreensDto implements IScreensDto {
    screenId?: number;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    isFinal?: boolean;
    screenParrentId?: number | undefined;

    constructor(data?: IScreensDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.screenId = _data["screenId"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.isFinal = _data["isFinal"];
            this.screenParrentId = _data["screenParrentId"];
        }
    }

    static fromJS(data: any): ScreensDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScreensDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["screenId"] = this.screenId;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["isFinal"] = this.isFinal;
        data["screenParrentId"] = this.screenParrentId;
        return data;
    }
}

export interface IScreensDto {
    screenId?: number;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    isFinal?: boolean;
    screenParrentId?: number | undefined;
}

export class ScreensDtoPagingResultDto implements IScreensDtoPagingResultDto {
    total?: number;
    result?: ScreensDto[] | undefined;

    constructor(data?: IScreensDtoPagingResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ScreensDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ScreensDtoPagingResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScreensDtoPagingResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface IScreensDtoPagingResultDto {
    total?: number;
    result?: ScreensDto[] | undefined;
}

export class SessionDto implements ISessionDto {
    userId?: string | undefined;
    userName?: string | undefined;
    jobId?: number;

    constructor(data?: ISessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): SessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["jobId"] = this.jobId;
        return data;
    }
}

export interface ISessionDto {
    userId?: string | undefined;
    userName?: string | undefined;
    jobId?: number;
}

export class TokenDto implements ITokenDto {
    token?: string | undefined;
    expiration?: Date;

    constructor(data?: ITokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new TokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITokenDto {
    token?: string | undefined;
    expiration?: Date;
}

export class TransferPurposesDto implements ITransferPurposesDto {
    id?: number;
    readOnly?: boolean;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    riskRate?: number;
    isActve?: number;

    constructor(data?: ITransferPurposesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.readOnly = _data["readOnly"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.riskRate = _data["riskRate"];
            this.isActve = _data["isActve"];
        }
    }

    static fromJS(data: any): TransferPurposesDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransferPurposesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["readOnly"] = this.readOnly;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["riskRate"] = this.riskRate;
        data["isActve"] = this.isActve;
        return data;
    }
}

export interface ITransferPurposesDto {
    id?: number;
    readOnly?: boolean;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    riskRate?: number;
    isActve?: number;
}

export class TransferPurposesDtoPagingResultDto implements ITransferPurposesDtoPagingResultDto {
    total?: number;
    result?: TransferPurposesDto[] | undefined;

    constructor(data?: ITransferPurposesDtoPagingResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TransferPurposesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransferPurposesDtoPagingResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransferPurposesDtoPagingResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITransferPurposesDtoPagingResultDto {
    total?: number;
    result?: TransferPurposesDto[] | undefined;
}

export class UserDto implements IUserDto {
    id?: string | undefined;
    userName!: string;
    fullName!: string;
    email!: string;
    password?: string | undefined;
    jobId?: number;
    phoneNumber!: string;
    userRoles?: UserRoleDto[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.jobId = _data["jobId"];
            this.phoneNumber = _data["phoneNumber"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["jobId"] = this.jobId;
        data["phoneNumber"] = this.phoneNumber;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserDto {
    id?: string | undefined;
    userName: string;
    fullName: string;
    email: string;
    password?: string | undefined;
    jobId?: number;
    phoneNumber: string;
    userRoles?: UserRoleDto[] | undefined;
}

export class UserDtoPagingResultDto implements IUserDtoPagingResultDto {
    total?: number;
    result?: UserDto[] | undefined;

    constructor(data?: IUserDtoPagingResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDtoPagingResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagingResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserDtoPagingResultDto {
    total?: number;
    result?: UserDto[] | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    roleId?: string | undefined;
    roleName?: string | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data;
    }
}

export interface IUserRoleDto {
    roleId?: string | undefined;
    roleName?: string | undefined;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    readonly temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            (<any>this).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}